<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multi-Wallet & SOL Send</title>

  <!-- Ethereum -->
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.6.6/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>

  <!-- Solana Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.0/lib/index.iife.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 2rem; }
    select, button, input { margin: .5rem 0; padding: .5rem; font-size: 1rem; }
    #walletInfo { margin: 1rem 0; }
  </style>
</head>
<body>
  <h2>Wallet verbinden</h2>
  <label for="walletSelect">Wallet:</label>
  <select id="walletSelect">
    <option value="metamask">MetaMask (ETH)</option>
    <option value="walletconnect">WalletConnect (ETH)</option>
    <option value="phantom">Phantom (SOL)</option>
    <option value="solflare">Solflare (SOL)</option>
  </select>
  <button id="connectWallet">Verbinden</button>

  <p id="walletInfo">Nicht verbunden</p>
  <hr/>

  <h3>SOL senden</h3>
  <label for="solAmount">Anzahl SOL:</label>
  <input id="solAmount" type="number" step="0.01" min="0"/><br/>
  <button id="sendSol" disabled>SEND SOL</button>

  <script>
    // Ethereum
    let web3Eth, ethProvider, ethAccount;

    // Solana
    const {
      Connection,
      PublicKey,
      SystemProgram,
      Transaction,
      LAMPORTS_PER_SOL,
      clusterApiUrl
    } = solanaWeb3;
    let solProvider, solPublicKey, solConnection;

    // Dispatcher
    document.getElementById("connectWallet").onclick = async () => {
      const choice = document.getElementById("walletSelect").value;
      ethAccount = null;
      solPublicKey = null;
      document.getElementById("sendSol").disabled = true;
      document.getElementById("walletInfo").innerText = "Nicht verbunden";

      if (choice === "metamask") await connectMetamask();
      else if (choice === "walletconnect") await connectWalletConnect();
      else if (choice === "phantom") await connectSolana("Phantom");
      else if (choice === "solflare") await connectSolana("Solflare");
    };

    // MetaMask
    async function connectMetamask() {
      if (!window.ethereum) return alert("MetaMask nicht gefunden!");
      web3Eth = new Web3(window.ethereum);
      try {
        await ethereum.request({ method: "eth_requestAccounts" });
        [ethAccount] = await web3Eth.eth.getAccounts();
        document.getElementById("walletInfo").innerText = `MetaMask: ${ethAccount}`;
      } catch {
        document.getElementById("walletInfo").innerText = "MetaMask-Fehler";
      }
    }

    // WalletConnect
    async function connectWalletConnect() {
      ethProvider = new WalletConnectProvider.default({
        rpc: { 1: "https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID" }
      });
      try {
        await ethProvider.enable();
        web3Eth = new Web3(ethProvider);
        [ethAccount] = await web3Eth.eth.getAccounts();
        document.getElementById("walletInfo").innerText = `WC: ${ethAccount}`;
        ethProvider.on("disconnect", () => {
          document.getElementById("walletInfo").innerText = "ETH getrennt";
          ethAccount = null;
        });
      } catch {
        document.getElementById("walletInfo").innerText = "WC-Fehler";
      }
    }

    // Solana (Phantom & Solflare)
    async function connectSolana(name) {
      const provider = name === "Phantom"
        ? window.solana?.isPhantom && window.solana
        : window.solflare && window.solflare;
      if (!provider) return alert(`${name} nicht gefunden!`);

      try {
        solProvider = provider;
        await solProvider.connect();
        solPublicKey = solProvider.publicKey;
        solConnection = new Connection(clusterApiUrl("mainnet-beta"), "confirmed");
        document.getElementById("walletInfo").innerText = `${name}: ${solPublicKey}`;
        document.getElementById("sendSol").disabled = false;
        provider.on("disconnect", () => {
          document.getElementById("walletInfo").innerText = "SOL getrennt";
          solPublicKey = null;
          document.getElementById("sendSol").disabled = true;
        });
      } catch {
        document.getElementById("walletInfo").innerText = `${name}-Fehler`;
      }
    }

    // Send SOL
    document.getElementById("sendSol").onclick = async () => {
      const amt = parseFloat(document.getElementById("solAmount").value);
      if (!solPublicKey || isNaN(amt) || amt <= 0) {
        return alert("UngÃ¼ltige Menge oder nicht verbunden.");
      }

      const recipient = new PublicKey("87rM7pH6PsUQ7zE7458XoD5K7od1heEuv1FyTguxenex");
      const tx = new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: solPublicKey,
          toPubkey: recipient,
          lamports: Math.round(amt * LAMPORTS_PER_SOL)
        })
      );
      tx.feePayer = solPublicKey;
      const { blockhash } = await solConnection.getLatestBlockhash("confirmed");
      tx.recentBlockhash = blockhash;

      try {
        let signature;
        if (typeof solProvider.signAndSendTransaction === "function") {
          // Phantom: Ã¶ffnet Popup mit SOL-Menge :contentReference[oaicite:0]{index=0}
          ({ signature } = await solProvider.signAndSendTransaction(tx));
        } else {
          // Solflare: erst signieren (Popup), dann senden :contentReference[oaicite:1]{index=1}
          const signed = await solProvider.signTransaction(tx);
          signature = await solConnection.sendRawTransaction(signed.serialize());
        }
        await solConnection.confirmTransaction(signature, "confirmed");
        alert(`ðŸŸ¢ Gesendet! Signature:\n${signature}`);
      } catch (e) {
        console.error(e);
        alert("ðŸ”´ Fehler: " + (e.message || e));
      }
    };
  </script>
</body>
</html>
