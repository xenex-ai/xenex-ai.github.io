<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multi-Wallet & SOL Send</title>

  <!-- Ethereum -->
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.6.6/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>

  <!-- Solana Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.0/lib/index.iife.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 2rem; }
    select, button, input { margin: .5rem 0; padding: .5rem; font-size: 1rem; }
    #walletInfo { margin: 1rem 0; color: #036; }
  </style>
</head>
<body>
  <h2>Wallet verbinden</h2>

  <label for="walletSelect">Wallet:</label>
  <select id="walletSelect">
    <option value="phantom">Phantom (SOL)</option>
    <option value="metamask">MetaMask (ETH)</option>
    <option value="walletconnect">WalletConnect (ETH)</option>
  </select>
  <button id="connectWallet">Verbinden</button>

  <p id="walletInfo">Nicht verbunden</p>
  <hr/>

  <h3>SOL senden</h3>
  <label for="solAmount">Anzahl SOL:</label>
  <input id="solAmount" type="number" step="0.001" min="0" value="0.01"/><br/>
  <button id="sendSol" disabled>SEND SOL</button>

  <script>
    // Ethereum-Variablen
    let web3Eth, ethProvider, ethAccount;

    // Solana-Variablen
    const {
      Connection,
      PublicKey,
      SystemProgram,
      Transaction,
      LAMPORTS_PER_SOL,
      clusterApiUrl
    } = solanaWeb3;
    let solProvider, solPublicKey, solConnection;

    // Wann auf „Verbinden“ klicken:
    document.getElementById('connectWallet').onclick = async () => {
      const choice = document.getElementById('walletSelect').value;
      // Reset
      ethAccount = null;
      solPublicKey = null;
      document.getElementById('sendSol').disabled = true;
      document.getElementById('walletInfo').innerText = 'Nicht verbunden';

      if (choice === 'phantom') {
        await connectPhantom();
      } else if (choice === 'metamask') {
        await connectMetamask();
      } else if (choice === 'walletconnect') {
        await connectWalletConnect();
      }
    };

    // --- Phantom (SOL) ---
    async function connectPhantom() {
      if (!window.solana?.isPhantom) {
        return alert('Phantom nicht gefunden!');
      }
      try {
        solProvider = window.solana;
        await solProvider.connect();
        solPublicKey = solProvider.publicKey;
        solConnection = new Connection(clusterApiUrl('mainnet-beta'), 'confirmed');
        document.getElementById('walletInfo').innerText = `Phantom: ${solPublicKey.toString()}`;
        document.getElementById('sendSol').disabled = false;
        solProvider.on('disconnect', () => {
          document.getElementById('walletInfo').innerText = 'Phantom getrennt';
          document.getElementById('sendSol').disabled = true;
        });
      } catch (e) {
        console.error(e);
        alert('Fehler beim Phantom-Connect: ' + e.message);
      }
    }

    // --- MetaMask (ETH) ---
    async function connectMetamask() {
      if (!window.ethereum) {
        return alert('MetaMask nicht gefunden!');
      }
      try {
        web3Eth = new Web3(window.ethereum);
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        [ethAccount] = await web3Eth.eth.getAccounts();
        document.getElementById('walletInfo').innerText = `MetaMask: ${ethAccount}`;
      } catch (e) {
        console.error(e);
        alert('Fehler bei MetaMask: ' + e.message);
      }
    }

    // --- WalletConnect (ETH) ---
    async function connectWalletConnect() {
      try {
        ethProvider = new WalletConnectProvider.default({
          rpc: { 1: 'https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID' }
        });
        await ethProvider.enable();
        web3Eth = new Web3(ethProvider);
        [ethAccount] = await web3Eth.eth.getAccounts();
        document.getElementById('walletInfo').innerText = `WalletConnect: ${ethAccount}`;
        ethProvider.on('disconnect', () => {
          document.getElementById('walletInfo').innerText = 'WalletConnect getrennt';
        });
      } catch (e) {
        console.error(e);
        alert('Fehler bei WalletConnect: ' + e.message);
      }
    }

    // --- SEND SOL ---
    document.getElementById('sendSol').onclick = async () => {
      const amt = parseFloat(document.getElementById('solAmount').value);
      if (!solPublicKey || isNaN(amt) || amt <= 0) {
        return alert('Ungültige SOL-Menge oder Phantom nicht verbunden.');
      }

      // Empfänger-Adresse und Transaktion bauen
      const recipient = new PublicKey('87rM7pH6PsUQ7zE7458XoD5K7od1heEuv1FyTguxenex');
      const lamports = Math.round(amt * LAMPORTS_PER_SOL);
      const tx = new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: solPublicKey,
          toPubkey: recipient,
          lamports
        })
      );
      tx.feePayer = solPublicKey;
      // Aktuellen Blockhash holen
      const { blockhash } = await solConnection.getLatestBlockhash('finalized');
      tx.recentBlockhash = blockhash;

      try {
        // **phantom.signAndSendTransaction** öffnet das Bestätigungs-Popup inkl. SOL-Menge
        const { signature } = await solProvider.signAndSendTransaction(tx, {
          preflightCommitment: 'finalized'
        });
        // Auf Bestätigung warten
        await solConnection.confirmTransaction(signature, 'finalized');
        alert(`✅ Gesendet! Signature:\n${signature}`);
      } catch (e) {
        console.error(e);
        alert('❌ Fehler beim Senden: ' + (e.message || e));
      }
    };
  </script>
</body>
</html>
